{
  "name": "sam",
  "tagline": "1000110001",
  "body": "   一.缓存的目的\r\n\r\n         引入缓存是为了提升系统的响应速度。\r\n    二.缓存的选择\r\n           1.jvm缓存,如  map set 等等\r\n                    优点:  1.不需要序列化/反序列化    \r\n                               2.不需要网络io\r\n                     缺点: 1.不支持过期\r\n                              2.有OOM的风险\r\n                              3.浪费内存,因为不同的jvm进程会缓存相同的数据\r\n                              4.不容易更新,如果要强制淘汰/更新缓存,需要引入消息中间件去订阅缓存更新消息\r\n           2.集中式缓存,如 memcached,redis\r\n                    优点:1.支持过期\r\n                             2.节省空间\r\n                     缺点:1.需要网络io,虽然是毫秒级别的\r\n                              2.需要序列化/反序列化\r\n      \r\n       三.二级缓存的设计\r\n               使用jvm缓存做一级缓存,redis做二级缓存\r\n                   1.如何支持jvm缓存过期?\r\n                     使用2个map，一个Map存key/value，一个map存key/过期时间,每次取值的时候先从存过期时间的map里取值,判断key是否过期,如果过期了就返回null同时在2个map里把这个key删掉\r\n                  2.如何防止oom\r\n                    使用google的ConcurrentLinkedHashMap, ConcurrentLinkedHashMap可以配置最多可以存多少key，超过这个值以后就会用LRU算法淘汰掉一部分key。\r\n                    但是这样做还是有OOM的风险,所以就要非常小心的去设置这个值\r\n              \r\n                 在大量命中jvm缓存的情况下二级缓存对性能的提升非常明显,但是如果key的分布非常离散,命中率很低的话二级缓存的意义就不是很大了,并且会带来额外的内存开销\r\n         \r\n  \r\n下面是一个二级缓存的具体实现,不过没有实现通过消息去淘汰本地缓存的逻辑\r\n\r\npublic class CacheComponent<T> implements InitializingBean {\r\n\r\n    @Value(\"${jedis}\")\r\n    String redisHost;\r\n\r\n    JedisPool jedisPool;\r\n\r\n    ConcurrentLinkedHashMap<String, T> localCache = new ConcurrentLinkedHashMap.Builder<String, T>().maximumWeightedCapacity(50000).build();\r\n\r\n    ConcurrentLinkedHashMap<String, Long> keyExpired = new ConcurrentLinkedHashMap.Builder<String, Long>().maximumWeightedCapacity(50000).build();\r\n\r\n    private int ONE_MINUTE = 60 ;\r\n\r\n\r\n    public void clearLocalCache(){\r\n        logger.info(new Date() + \"clearLocalCache\");\r\n        localCache.clear();\r\n        keyExpired.clear();\r\n    }\r\n\r\n    public void printLocalCacheSize(){\r\n        logger.info(\"localCacheSize:{},keyExpiredSize:{}\",localCache.size(),keyExpired.size());\r\n    }\r\n\r\n    @Value(\"${env}\")\r\n    String env;\r\n\r\n    private static final Logger logger = LoggerFactory.getLogger(CacheComponent.class);\r\n\r\n    public void set(String key, T value) {\r\n        set(key, value, ONE_MINUTE * 10);\r\n    }\r\n\r\n\r\n    public void set(String key, T value, int expiredInSecond) {\r\n        Jedis jedis = null;\r\n        try {\r\n            jedis = jedisPool.getResource();\r\n            jedis.select(1);\r\n            key = env + \"_\" + key;\r\n            String valueStr = new Gson().toJson(value);\r\n            jedis.setex(key, expiredInSecond, valueStr);\r\n            putToLocalCache(key, value, expiredInSecond);\r\n        } catch (Exception e) {\r\n            logger.error(\"\", e);\r\n        } finally {\r\n            if (jedis != null) {\r\n                jedis.close();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void putToLocalCache(String key, T value, long expiredInSecond) {\r\n        localCache.put(key, value);\r\n        //本地缓存最多只缓存1个小时\r\n        if (expiredInSecond > ExpiredTimeConstant.ONE_HOUR_IN_SECOND) {\r\n            keyExpired.put(key, System.currentTimeMillis() +  ExpiredTimeConstant.ONE_HOUR_IN_SECOND * 1000);\r\n        } else {\r\n            keyExpired.put(key, System.currentTimeMillis() + expiredInSecond * 1000);\r\n        }\r\n    }\r\n\r\n    public T get(String key, Class clazz) {\r\n        long start = System.currentTimeMillis();\r\n        key = env + \"_\" + key;\r\n        Long expiredInMs = keyExpired.get(key);\r\n        T value;\r\n        if (expiredInMs != null && expiredInMs > System.currentTimeMillis()) {\r\n            value = localCache.get(key);\r\n            if (value != null) {\r\n                logger.debug(\"hit localCache,key:{},cost:{}ms,localCache keySize:{},keyExpired keySize:{}\", key, System.currentTimeMillis() - start, localCache.size(), keyExpired.size());\r\n                return (T) value;\r\n            }\r\n        }\r\n        Jedis jedis = null;\r\n        try {\r\n            jedis = jedisPool.getResource();\r\n            jedis.select(1);\r\n            String ret = jedis.get(key);\r\n            if (StringUtils.isEmpty(ret)) {\r\n                logger.debug(\"can not find cache in localCache or redisCache,key:{},cost:{}ms\", key, System.currentTimeMillis() - start);\r\n                return null;\r\n            }\r\n            long expiredSecond = jedis.ttl(key);\r\n            value = (T) new Gson().fromJson(ret, clazz);\r\n            putToLocalCache(key, value, expiredSecond);\r\n            logger.debug(\"hit redis cache ,cache to localcache,key:{},cost:{}ms\", key, System.currentTimeMillis() - start);\r\n            return value;\r\n        } catch (Exception e) {\r\n            logger.error(\"\", e);\r\n            return null;\r\n        } finally {\r\n            if (jedis != null) {\r\n                jedis.close();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void afterPropertiesSet() throws Exception {\r\n        GenericObjectPoolConfig genericObjectPoolConfig = new GenericObjectPoolConfig();\r\n        genericObjectPoolConfig.setMaxIdle(25);\r\n        genericObjectPoolConfig.setMinIdle(5);\r\n        genericObjectPoolConfig.setTimeBetweenEvictionRunsMillis(4000);\r\n        genericObjectPoolConfig.setTestOnBorrow(true);\r\n        genericObjectPoolConfig.setMaxTotal(50);\r\n        jedisPool = new JedisPool(genericObjectPoolConfig, redisHost, 6379, 1000);\r\n        logger.debug(\"init jedis pool:{}\", redisHost);\r\n    }\r\n\r\n    @Bean\r\n    public JedisPool jedisPool(){\r\n        return jedisPool;\r\n    }\r\n\r\n  \r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}